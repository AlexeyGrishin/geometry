// Generated by CoffeeScript 1.6.3
var angleToPoint, generateCirclePoints, generatePolyline, generateRhombusPoints, generateTrianglePoints, numbersBetween, numbersBetweenInclusive, pointsBetween, pointsBetweenInclusive, transitionBetween;

numbersBetween = function(a1, a2, amount) {
  var cursor, direction, distance, numbers, step;
  distance = Math.abs(a2 - a1);
  direction = a2 > a1 ? 1 : -1;
  step = direction * distance / (amount + 1);
  numbers = [];
  cursor = a1;
  while (amount-- > 0) {
    cursor += step;
    numbers.push(cursor);
  }
  return numbers;
};

numbersBetweenInclusive = function(a1, a2, amount) {
  return [a1].concat(numbersBetween(a1, a2, amount - 2)).concat([a2]);
};

pointsBetween = function(p1, p2, amount) {
  var xs, ys;
  xs = numbersBetween(p1[0], p2[0], amount);
  ys = numbersBetween(p1[1], p2[1], amount);
  return xs.map(function(x, index) {
    return [x, ys[index]];
  });
};

pointsBetweenInclusive = function(p1, p2, amount) {
  return [p1].concat(pointsBetween(p1, p2, amount - 2)).concat([p2]);
};

transitionBetween = function(figure1, figure2, amount) {
  var figuresPerStep, transitionsPerPoints, _i, _results;
  if (figure1.length !== figure2.length) {
    throw "Figures shall have identical amount of points";
  }
  transitionsPerPoints = figure1.map(function(point, index) {
    return pointsBetweenInclusive(point, figure2[index], amount);
  });
  figuresPerStep = (function() {
    _results = [];
    for (var _i = 0; 0 <= amount ? _i < amount : _i > amount; 0 <= amount ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this).map(function(step) {
    return transitionsPerPoints.map(function(pointSteps) {
      return pointSteps[step];
    });
  });
  return figuresPerStep;
};

generatePolyline = function(corners, amounts) {
  var index, point, points, _i, _len, _ref;
  points = [];
  _ref = corners.slice(0, corners.length - 1);
  for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
    point = _ref[index];
    points.push(point);
    points = points.concat(pointsBetween(point, corners[index + 1], amounts[index]));
  }
  return points;
};

generateRhombusPoints = function(w, h, amountInQuarter) {
  var BOTTOM, LEFT, RIGHT, TOP;
  TOP = [0, -h];
  RIGHT = [w, 0];
  BOTTOM = [0, h];
  LEFT = [-w, 0];
  return generatePolyline([TOP, RIGHT, BOTTOM, LEFT, TOP], [amountInQuarter, amountInQuarter, amountInQuarter, amountInQuarter]);
};

angleToPoint = function(r, angle) {
  return [Math.cos(angle) * r, Math.sin(angle) * r];
};

generateCirclePoints = function(r, amountInQuarter) {
  var BOTTOM, LEFT, RIGHT, TOP, angle, angles, index, points, _i, _len, _ref;
  TOP = -Math.PI / 2;
  RIGHT = 0;
  BOTTOM = Math.PI / 2;
  LEFT = Math.PI;
  points = [];
  angles = [TOP, RIGHT, BOTTOM, LEFT, TOP + 2 * Math.PI];
  _ref = angles.slice(0, 4);
  for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
    angle = _ref[index];
    points.push(angleToPoint(r, angle));
    points = points.concat((numbersBetween(angle, angles[index + 1], amountInQuarter)).map(angleToPoint.bind(null, r)));
  }
  return points;
};

generateTrianglePoints = function(r, amountInQuarter) {
  var LEFT_BOTTOM, RIGHT_BOTTOM, TOP, amountOnEdge, amountOnLastEdge, totalPointsButCorner;
  TOP = angleToPoint(r, -Math.PI / 2);
  RIGHT_BOTTOM = angleToPoint(r, -Math.PI / 2 + Math.PI * 2 / 3);
  LEFT_BOTTOM = angleToPoint(r, -Math.PI / 2 - Math.PI * 2 / 3);
  totalPointsButCorner = (amountInQuarter + 1) * 4 - 3;
  amountOnEdge = Math.ceil(totalPointsButCorner / 3);
  amountOnLastEdge = totalPointsButCorner - amountOnEdge * 2;
  return generatePolyline([TOP, RIGHT_BOTTOM, LEFT_BOTTOM, TOP], [amountOnEdge, amountOnEdge, amountOnLastEdge]);
};
