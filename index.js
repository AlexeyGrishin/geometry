// Generated by CoffeeScript 1.6.3
var CX, CY, DELAY_ON_SCROLL, DH, DW, H, POINTS, STEPS, STEP_ON_SCROLL, W, clear, drawFigure, drawPoints, initAnimation, initCanvas, initialize, moveFigure, realX, realY;

POINTS = 50;

STEPS = 80;

STEP_ON_SCROLL = 10;

DELAY_ON_SCROLL = 10;

$(function() {
  var animation, canvas, circle, colors, drawStep, movement, onStep, rhombus, rhombusToCircle, rhombusToTriangleToCircle, transition, triangle;
  canvas = initCanvas();
  rhombus = generateRhombusPoints(0.3, 0.4, POINTS);
  triangle = generateTrianglePoints(0.4, POINTS);
  circle = generateCirclePoints(0.4, POINTS);
  rhombusToCircle = function() {
    return transitionBetween(rhombus, circle, STEPS);
  };
  rhombusToTriangleToCircle = function() {
    var firstSteps, secondSteps;
    firstSteps = Math.floor(STEPS / 2) + 1;
    secondSteps = STEPS - firstSteps + 1;
    return (transitionBetween(rhombus, triangle, firstSteps)).concat((transitionBetween(triangle, circle, secondSteps)).slice(1));
  };
  transition = rhombusToTriangleToCircle();
  colors = colorsBetweenInclusive(randomColor(), randomColor(), STEPS);
  movement = numbersBetweenInclusive(-0.4, 0.4, STEPS);
  drawStep = function(step) {
    clear(canvas);
    canvas.fillStyle = colorToString(colors[step]);
    return drawFigure(canvas, moveFigure(transition[step], 0, movement[step]));
  };
  onStep = function(step) {
    if (step === STEPS - 1) {
      return colors = colorsBetweenInclusive(randomColor(), colors[colors.length - 1], STEPS);
    } else if (step === 0) {
      return colors = colorsBetweenInclusive(colors[0], randomColor(), STEPS);
    }
  };
  animation = initAnimation(drawStep, transition.length, onStep);
  console.log("before resize");
  return $(window).resize(function() {
    initCanvas();
    return animation.draw();
  });
});

initAnimation = function(drawStep, stepsAmount, onStep) {
  var animation;
  animation = {
    currentStep: 0,
    currentMotionTo: 0,
    targetStep: 0,
    animateTo: function(targetStep) {
      var nextStep,
        _this = this;
      this.targetStep = targetStep;
      clearTimeout(this.currentMotionTo);
      nextStep = function() {
        _this.move(_this.currentStep < _this.targetStep);
        _this.draw();
        if (_this.currentStep !== _this.targetStep) {
          return _this.currentMotionTo = setTimeout(nextStep, DELAY_ON_SCROLL);
        } else {
          return console.log(_this.currentStep);
        }
      };
      return nextStep();
    },
    move: function(forward) {
      if (forward && this.currentStep < stepsAmount - 1) {
        this.currentStep++;
      }
      if (!forward && this.currentStep > 0) {
        this.currentStep--;
      }
      this.draw();
      return this._onCurrentStepChange();
    },
    _onCurrentStepChange: function() {
      return onStep(this.currentStep);
    },
    animate: function(forward) {
      if (forward && this.currentStep < stepsAmount - 1) {
        this.animateTo(Math.min(this.currentStep + STEP_ON_SCROLL, stepsAmount - 1));
      }
      if (!forward && this.currentStep > 0) {
        return this.animateTo(Math.max(this.currentStep - STEP_ON_SCROLL, 0));
      }
    },
    start: function() {
      this.currentStep = 0;
      return this.draw();
    },
    end: function() {
      this.currentStep = stepsAmount - 1;
      return this.draw();
    },
    draw: function() {
      return drawStep(this.currentStep);
    }
  };
  onvscroll(function(down) {
    return animation.animate(down);
  });
  animation.start();
  return animation;
};

W = null;

H = null;

CX = null;

CY = null;

DW = null;

DH = null;

initialize = function(width, height) {
  var PAD;
  W = width;
  H = height;
  CX = W / 2;
  CY = H / 2;
  PAD = 5;
  DW = W / 2 - PAD;
  return DH = H / 2 - PAD;
};

clear = function(canvas) {
  return canvas.clearRect(0, 0, W, H);
};

realX = function(p) {
  var _ref;
  return ((_ref = p[0]) != null ? _ref : p) * DW + CX;
};

realY = function(p) {
  var _ref;
  return ((_ref = p[1]) != null ? _ref : p) * DH + CY;
};

drawPoints = function(canvas, points) {
  return points.forEach(function(_arg) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return canvas.fillRect(realX(x) - 1, realY(y) - 1, 2, 2);
  });
};

moveFigure = function(points, offsetX, offsetY) {
  return points.map(function(p) {
    return [p[0] + offsetX, p[1] + offsetY];
  });
};

drawFigure = function(canvas, points) {
  canvas.beginPath();
  canvas.moveTo(realX(points[0]), realY(points[0]));
  points.slice(1).forEach(function(_arg) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return canvas.lineTo(realX(x), realY(y));
  });
  canvas.closePath();
  return canvas.fill();
};

initCanvas = function() {
  var el, size;
  el = $("canvas");
  size = Math.min($(window).width(), $(window).height());
  el.attr("width", size);
  el.attr("height", size);
  initialize(el.width(), el.height());
  console.log("getCtx is " + $("canvas")[0].getContext);
  return $("canvas")[0].getContext("2d");
};
